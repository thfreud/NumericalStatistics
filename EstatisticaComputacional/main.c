#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <gsl/gsl_multimin.h>
#include <time.h>
#include <gsl/gsl_statistics.h>
#include "metodos.h"

/* main method */

int main(void)
{
    FILE* reg;
    reg = fopen("data.txt", "w+");
    //if save = 1 then the data shall be recorded in a file.
    int save = 0;
    //To keep tracking the time of execution
    clock_t begin = clock();
    /*Setting Monte Carlo configuration*/
    /*Setting Weibull parameters for the samples to be generated*/
    double shape = 3; //b
    double scale = 90; //c
    int success_count = 0;
    int fails_count = 0;
    int sample_size = 30;
    /*
    printf("Enter with the sample size: ");
    scanf("%d", &sample_size);
    printf("Would you like to recorde the data in a file? (0 = no, 1 = yes)");
    scanf("%d", &save); */
    int nRep = 10000;
    double* reg_shape = allocation(nRep);
    double* reg_scale = allocation(nRep);
    size_t semente = 1990;
    /* Generating a nRep size vector of uniform random numbers necessary for generate Weibull samples */
    double* uniform = 0;
    uniform = generator(&semente, nRep * sample_size);
    int j = 0;
    for (int i = 0; i < nRep; i++) {
        size_t iter = 0;
        int status;

        const gsl_multimin_fdfminimizer_type* T;
        gsl_multimin_fdfminimizer* s;

        /* generating the Weibull sample according
           to our function previously declared and the vector of uniform random numbers */
        int offsetUniform =  (sample_size - 1)* j;
        ++j;
        double* par = 0;
        par = rWeibull(sample_size, scale, shape, (uniform + offsetUniform));
       
        gsl_vector* x;
        gsl_multimin_function_fdf my_func;

        my_func.n = 2;
        my_func.f = my_f;
        my_func.df = my_df;
        my_func.fdf = my_fdf;
        my_func.params = par;

        
        //initial guess c = 5 and b = 1

        x = gsl_vector_alloc(2);
        gsl_vector_set(x, 0, 5);
        gsl_vector_set(x, 1, 88);


        T = gsl_multimin_fdfminimizer_vector_bfgs2;
        // T = gsl_multimin_fdfminimizer_conjugate_fr;
        s = gsl_multimin_fdfminimizer_alloc(T, 2);
        gsl_vector* grad = gsl_multimin_fdfminimizer_gradient(s);
        gsl_multimin_fdfminimizer_set(s, &my_func, x, 1e-7, 1e-3);

        do
        {
            iter++;
            status = gsl_multimin_fdfminimizer_iterate(s);


            if (status)
                break;

            status = gsl_multimin_test_gradient(s->gradient, 1e-3);

            if (status == GSL_SUCCESS) {
                ++success_count;
                printf("\r%d: ",i);/*
                printf("%5d %.5f %.5f %10.5f %.5f %.5f\n", iter,
                    gsl_vector_get(s->x, 0),
                    gsl_vector_get(s->x, 1),
                    s->f,
                    gsl_vector_get(grad, 0), gsl_vector_get(grad, 1));
                    */
                /* saving estimators*/
                /* configuring access in a two-dimensional array */
                *(reg_shape + i) = gsl_vector_get(s->x, 0);
                *(reg_scale + i) = gsl_vector_get(s->x, 1);
            }
            
        } while (status == GSL_CONTINUE && iter < 100);
        if (status != GSL_SUCCESS) {
            
            // getting the last seed which was generated by the recurrence relation in the congruential generator
            // it is used an offset index for jumping the seed the had generated the last sample
            semente = *(uniform + (sample_size - 1) * j) * M;
            free(uniform);
            --i;
            /* here is generated a new vector of uniform random numbers 
            using the seed which had been chosen early at line number 105.*/ 
            uniform = generator(&semente, (nRep-i) * sample_size);
            j = 0;
            ++fails_count;
            
            continue;
        }
        gsl_multimin_fdfminimizer_free(s);
        gsl_vector_free(x);
        free(par);

        /* end loop */
    }
    //printing summary on the screen
    printData(reg_shape, reg_scale, nRep, shape, scale, sample_size);
    /*saving in a file the record of scale and shape values that was caught inside the Monte Carlo loop if
    save variable is true*/
    if (save == 1) {
        fprintf(reg, "Sample size of %d with %d Monte Carlo repetitions.\n", sample_size, nRep);
        fprintf(reg, "\nShape \t Scale \n");
        for (int i = 0; i < nRep; i++) {
            fprintf(reg, "%.2f \t%.2f\n", reg_shape[i], reg_scale[i]);
        }
    }
    fclose(reg);
    free(reg_shape);
    free(reg_scale);
    free(uniform);
    printf("\nMonte Carlo executions: %d", success_count);
    printf("\nIterations Fail Rate: %.4f%c", (double) 100*fails_count/nRep, '%');
    clock_t end = clock();
    
    double TIME_E = ((double)(end - begin)) / CLOCKS_PER_SEC;
    printf("\nThe time of execution was %.3f seconds.",  TIME_E);
    
    
    return 0;
}